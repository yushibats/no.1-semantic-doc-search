"""
画像ベクトル化サービス
OCI Generative AI Embedding Modelを使用して画像をベクトル化し、DBに保存
"""
import logging
import os
import io
import array
import time
from typing import Optional, List, Dict, Any
from pathlib import Path
import numpy as np
from PIL import Image
import base64
import oracledb
import oci
from pdf2image import convert_from_path

logger = logging.getLogger(__name__)


class ImageVectorizer:
    """画像ベクトル化クラス"""
    
    def __init__(self):
        self.genai_client = None
        self.db_connection = None
        self._initialize_genai_only()
        logger.info("ImageVectorizerを初期化しました（DB接続は遅延作成）")
    
    def _initialize_genai_only(self):
        """OCIクライアントのみを初期化（DB接続は遅延作成）"""
        try:
            # OCI設定を読み込み
            config_file = os.path.expanduser("~/.oci/config")
            profile = os.getenv("OCI_PROFILE", "DEFAULT")
            
            if not os.path.exists(config_file):
                logger.warning(f"OCI設定ファイルが見つかりません: {config_file}")
                return
            
            config = oci.config.from_file(file_location=config_file, profile_name=profile)
            
            # OCI Generative AI Clientを初期化
            region = os.getenv("OCI_REGION", "us-chicago-1")
            service_endpoint = f"https://inference.generativeai.{region}.oci.oraclecloud.com"
            
            self.genai_client = oci.generative_ai_inference.GenerativeAiInferenceClient(
                config=config,
                service_endpoint=service_endpoint,
                retry_strategy=oci.retry.NoneRetryStrategy(),
                timeout=(10, 240)
            )
            
            logger.info("OCI Generative AIクライアント初期化成功")
            
        except Exception as e:
            logger.error(f"GenAI初期化エラー: {e}")
            self.genai_client = None
    
    def _ensure_db_connection(self, max_retries: int = 3) -> bool:
        """データベース接続を確保（database_serviceから取得）"""
        from app.services.database_service import database_service
        
        # 既存接続が有効かチェック
        if self.db_connection:
            if self.is_connected():
                return True
            else:
                logger.warning("既存のDB接続が無効です")
                # 無効な接続をクローズ
                try:
                    database_service._release_connection(self.db_connection)
                except:
                    pass
                self.db_connection = None
        
        # database_serviceから接続を取得（リトライ付き）
        for attempt in range(1, max_retries + 1):
            try:
                logger.info(f"DB接続取得試行 {attempt}/{max_retries}")
                self.db_connection = database_service._create_connection()
                if self.db_connection:
                    logger.info(f"DB接続取得成功 (試行{attempt}回目)")
                    # テーブル存在確認
                    self._ensure_tables_exist()
                    return True
            except Exception as e:
                logger.error(f"DB接続取得失敗 (試行{attempt}/{max_retries}): {e}")
                if attempt == max_retries:
                    logger.error("DB接続取得の最大リトライ回数に達しました")
                    return False
                # リトライ前に少し待機
                import time
                time.sleep(1)
        
        return False
    

    
    def is_connected(self) -> bool:
        """データベース接続状態をチェック"""
        try:
            if self.db_connection is None:
                return False
            # 簡単なクエリでテスト
            with self.db_connection.cursor() as cursor:
                cursor.execute("SELECT 1 FROM DUAL")
                cursor.fetchone()
            return True
        except Exception:
            return False
    
    def _ensure_tables_exist(self):
        """必要なテーブルが存在することを確認し、なければ作成"""
        if not self.db_connection:
            return
        
        try:
            with self.db_connection.cursor() as cursor:
                # FILE_INFOテーブルの存在確認
                cursor.execute("""
                    SELECT COUNT(*) 
                    FROM USER_TABLES 
                    WHERE TABLE_NAME = 'FILE_INFO'
                """)
                file_info_exists = cursor.fetchone()[0] > 0
                
                if not file_info_exists:
                    logger.info("FILE_INFOテーブルを作成します...")
                    cursor.execute("""
                        CREATE TABLE FILE_INFO (
                            FILE_ID NUMBER GENERATED BY DEFAULT AS IDENTITY 
                                MINVALUE 1 
                                MAXVALUE 9999999999999999999999999999 
                                INCREMENT BY 1 
                                START WITH 1 
                                CACHE 20 
                                NOORDER NOCYCLE NOKEEP NOSCALE,
                            BUCKET VARCHAR2(128 BYTE) COLLATE USING_NLS_COMP,
                            OBJECT_NAME VARCHAR2(1024 BYTE) COLLATE USING_NLS_COMP,
                            ORIGINAL_FILENAME VARCHAR2(1024 BYTE) COLLATE USING_NLS_COMP,
                            FILE_SIZE NUMBER,
                            CONTENT_TYPE VARCHAR2(128 BYTE) COLLATE USING_NLS_COMP,
                            UPLOADED_AT TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
                            CONSTRAINT PK_FILE_INFO PRIMARY KEY (FILE_ID)
                        ) DEFAULT COLLATION USING_NLS_COMP
                    """)
                    self.db_connection.commit()
                    logger.info("FILE_INFOテーブル作成完了")
                
                # IMG_EMBEDDINGSテーブルの存在確認
                cursor.execute("""
                    SELECT COUNT(*) 
                    FROM USER_TABLES 
                    WHERE TABLE_NAME = 'IMG_EMBEDDINGS'
                """)
                img_embeddings_exists = cursor.fetchone()[0] > 0
                
                if not img_embeddings_exists:
                    logger.info("IMG_EMBEDDINGSテーブルを作成します...")
                    cursor.execute("""
                        CREATE TABLE IMG_EMBEDDINGS (
                            ID NUMBER GENERATED BY DEFAULT AS IDENTITY 
                                MINVALUE 1 
                                MAXVALUE 9999999999999999999999999999 
                                INCREMENT BY 1 
                                START WITH 1 
                                CACHE 20 
                                NOORDER NOCYCLE NOKEEP NOSCALE,
                            FILE_ID NUMBER,
                            BUCKET VARCHAR2(128 BYTE) COLLATE USING_NLS_COMP,
                            OBJECT_NAME VARCHAR2(1024 BYTE) COLLATE USING_NLS_COMP,
                            PAGE_NUMBER NUMBER,
                            CONTENT_TYPE VARCHAR2(128 BYTE) COLLATE USING_NLS_COMP,
                            FILE_SIZE NUMBER,
                            UPLOADED_AT TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
                            EMBEDDING VECTOR(1536, FLOAT32),
                            CONSTRAINT PK_IMG_EMBEDDINGS PRIMARY KEY (ID),
                            CONSTRAINT FK_IMG_FILE FOREIGN KEY (FILE_ID) 
                                REFERENCES FILE_INFO(FILE_ID) ON DELETE CASCADE
                        ) DEFAULT COLLATION USING_NLS_COMP
                    """)
                    self.db_connection.commit()
                    logger.info("IMG_EMBEDDINGSテーブル作成完了")
                
        except Exception as e:
            logger.error(f"テーブル作成エラー: {e}")
            if self.db_connection:
                self.db_connection.rollback()
    
    def _image_to_base64(self, image_data: io.BytesIO, content_type: str = "image/png") -> str:
        """画像データをbase64エンコード"""
        image_data.seek(0)
        image_bytes = image_data.read()
        base64_string = base64.b64encode(image_bytes).decode('utf-8')
        return f"data:{content_type};base64,{base64_string}"
    
    def generate_embedding(self, image_data: io.BytesIO, content_type: str = "image/png") -> Optional[np.ndarray]:
        """画像からembeddingベクトルを生成"""
        # GenAIクライアントが初期化されていない場合、リトライして初期化を試みる
        if not self.genai_client:
            max_init_retries = 3
            for retry in range(1, max_init_retries + 1):
                logger.warning(f"OCI Generative AIクライアントが初期化されていません。再初期化を試みます（{retry}/{max_init_retries}回目）")
                self._initialize_genai_only()
                if self.genai_client:
                    logger.info(f"OCI Generative AIクライアント再初期化成功（{retry}回目）")
                    break
                if retry < max_init_retries:
                    time.sleep(1)  # 1秒待機してリトライ
            
            if not self.genai_client:
                logger.error(f"OCI Generative AIクライアントの初期化に失敗しました（{max_init_retries}回リトライ）")
                return None
        
        try:
            # 画像をbase64エンコード
            base64_image = self._image_to_base64(image_data, content_type)
            
            # Embedding生成リクエストを作成
            embed_detail = oci.generative_ai_inference.models.EmbedTextDetails()
            embed_detail.serving_mode = oci.generative_ai_inference.models.OnDemandServingMode(
                model_id=os.getenv("OCI_COHERE_EMBED_MODEL", "cohere.embed-v4.0")
            )
            embed_detail.input_type = os.getenv("OCI_EMBEDDING_INPUT_TYPE", "IMAGE")
            embed_detail.inputs = [base64_image]
            embed_detail.truncate = os.getenv("OCI_EMBEDDING_TRUNCATE", "END")
            embed_detail.compartment_id = os.getenv("OCI_COMPARTMENT_OCID")
            
            # リトライロジック
            max_retries = int(os.getenv("OCI_EMBEDDING_MAX_RETRIES", "3"))
            retry_delay = int(os.getenv("OCI_EMBEDDING_RETRY_DELAY", "1"))
            
            for retry in range(max_retries):
                try:
                    response = self.genai_client.embed_text(embed_detail)
                    
                    if response.data.embeddings:
                        embedding = response.data.embeddings[0]
                        embedding_array = np.array(embedding, dtype=np.float32)
                        
                        logger.info(f"画像embedding生成成功: shape={embedding_array.shape}")
                        return embedding_array
                    else:
                        logger.error("Embeddingが空です")
                        return None
                
                except Exception as e:
                    if retry < max_retries - 1:
                        logger.warning(f"Embedding生成失敗 (リトライ {retry + 1}/{max_retries}): {e}")
                        time.sleep(retry_delay)
                    else:
                        logger.error(f"Embedding生成失敗（最大リトライ回数到達）: {e}")
                        return None
            
            return None
            
        except Exception as e:
            logger.error(f"予期しないエラー: {e}")
            return None
    
    def generate_text_embedding(self, text: str) -> Optional[np.ndarray]:
        """テキストからembeddingベクトルを生成（検索クエリ用）"""
        # GenAIクライアントが初期化されていない場合、リトライして初期化を試みる
        if not self.genai_client:
            max_init_retries = 3
            for retry in range(1, max_init_retries + 1):
                logger.warning(f"OCI Generative AIクライアントが初期化されていません。再初期化を試みます（{retry}/{max_init_retries}回目）")
                self._initialize_genai_only()
                if self.genai_client:
                    logger.info(f"OCI Generative AIクライアント再初期化成功（{retry}回目）")
                    break
                if retry < max_init_retries:
                    time.sleep(1)  # 1秒待機してリトライ
            
            if not self.genai_client:
                logger.error(f"OCI Generative AIクライアントの初期化に失敗しました（{max_init_retries}回リトライ）")
                return None
        
        try:
            # Embedding生成リクエストを作成
            embed_detail = oci.generative_ai_inference.models.EmbedTextDetails()
            embed_detail.serving_mode = oci.generative_ai_inference.models.OnDemandServingMode(
                model_id=os.getenv("OCI_COHERE_EMBED_MODEL", "cohere.embed-v4.0")
            )
            embed_detail.input_type = "SEARCH_QUERY"  # 検索クエリ用
            embed_detail.inputs = [text]
            embed_detail.truncate = os.getenv("OCI_EMBEDDING_TRUNCATE", "END")
            embed_detail.compartment_id = os.getenv("OCI_COMPARTMENT_OCID")
            
            # リトライロジック
            max_retries = int(os.getenv("OCI_EMBEDDING_MAX_RETRIES", "3"))
            retry_delay = int(os.getenv("OCI_EMBEDDING_RETRY_DELAY", "1"))
            
            for retry in range(max_retries):
                try:
                    response = self.genai_client.embed_text(embed_detail)
                    
                    if response.data.embeddings:
                        embedding = response.data.embeddings[0]
                        embedding_array = np.array(embedding, dtype=np.float32)
                        
                        logger.info(f"テキストembedding生成成功: text_len={len(text)}, shape={embedding_array.shape}")
                        return embedding_array
                    else:
                        logger.error("Embeddingが空です")
                        return None
                
                except Exception as e:
                    if retry < max_retries - 1:
                        logger.warning(f"テキストembedding生成失敗 (リトライ {retry + 1}/{max_retries}): {e}")
                        time.sleep(retry_delay)
                    else:
                        logger.error(f"テキストembedding生成失敗（最大リトライ回数到達）: {e}")
                        return None
            
            return None
            
        except Exception as e:
            logger.error(f"予期しないエラー: {e}")
            return None
    
    def save_file_info(self, bucket: str, object_name: str, original_filename: str, 
                      file_size: int, content_type: str) -> Optional[int]:
        """ファイル情報をFILE_INFOテーブルに保存"""
        if not self._ensure_db_connection():
            logger.error("データベース接続がありません")
            return None
        
        try:
            with self.db_connection.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO FILE_INFO 
                    (BUCKET, OBJECT_NAME, ORIGINAL_FILENAME, FILE_SIZE, CONTENT_TYPE)
                    VALUES (:bucket, :object_name, :original_filename, :file_size, :content_type)
                    RETURNING FILE_ID INTO :file_id
                """, {
                    'bucket': bucket,
                    'object_name': object_name,
                    'original_filename': original_filename,
                    'file_size': file_size,
                    'content_type': content_type,
                    'file_id': cursor.var(oracledb.NUMBER)
                })
                
                file_id_var = cursor.bindvars['file_id']
                file_id = file_id_var.getvalue()
                
                if isinstance(file_id, list) and len(file_id) > 0:
                    file_id = file_id[0]
                
                self.db_connection.commit()
                
                logger.info(f"ファイル情報保存成功: FILE_ID={file_id}")
                return int(file_id)
                
        except Exception as e:
            logger.error(f"ファイル情報保存エラー: {e}")
            if self.db_connection:
                self.db_connection.rollback()
            return None
        finally:
            # 接続をクローズ
            self._release_db_connection()
    
    def save_image_embedding(self, file_id: int, bucket: str, object_name: str, 
                           page_number: int, content_type: str, file_size: int, 
                           embedding: np.ndarray) -> Optional[int]:
        """画像embeddingをIMG_EMBEDDINGSテーブルに保存"""
        if not self._ensure_db_connection():
            logger.error("データベース接続がありません")
            return None
        
        try:
            # NumPy配列をFLOAT32配列に変換
            embedding_array = array.array("f", embedding.tolist())
            
            with self.db_connection.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO IMG_EMBEDDINGS 
                    (FILE_ID, BUCKET, OBJECT_NAME, PAGE_NUMBER, CONTENT_TYPE, FILE_SIZE, EMBEDDING)
                    VALUES (:file_id, :bucket, :object_name, :page_number, :content_type, :file_size, :embedding)
                    RETURNING ID INTO :id
                """, {
                    'file_id': file_id,
                    'bucket': bucket,
                    'object_name': object_name,
                    'page_number': page_number,
                    'content_type': content_type,
                    'file_size': file_size,
                    'embedding': embedding_array,
                    'id': cursor.var(oracledb.NUMBER)
                })
                
                id_var = cursor.bindvars['id']
                embedding_id = id_var.getvalue()
                
                if isinstance(embedding_id, list) and len(embedding_id) > 0:
                    embedding_id = embedding_id[0]
                
                self.db_connection.commit()
                
                logger.info(f"画像embedding保存成功: ID={embedding_id}, FILE_ID={file_id}, PAGE={page_number}")
                return int(embedding_id)
                
        except Exception as e:
            logger.error(f"画像embedding保存エラー: {e}")
            if self.db_connection:
                self.db_connection.rollback()
            return None
        finally:
            # 接続をクローズ
            self._release_db_connection()
    
    def delete_file_embeddings(self, file_id: int) -> bool:
        """ファイルに関連するすべてのembeddingを削除"""
        if not self._ensure_db_connection():
            logger.error("データベース接続がありません")
            return False
        
        try:
            with self.db_connection.cursor() as cursor:
                cursor.execute("""
                    DELETE FROM IMG_EMBEDDINGS 
                    WHERE FILE_ID = :file_id
                """, {'file_id': file_id})
                
                deleted_count = cursor.rowcount
                self.db_connection.commit()
                
                logger.info(f"FILE_ID={file_id}のembedding削除完了: {deleted_count}件")
                return True
                
        except Exception as e:
            logger.error(f"Embedding削除エラー: {e}")
            if self.db_connection:
                self.db_connection.rollback()
            return False
        finally:
            # 接続をクローズ
            self._release_db_connection()
    
    def get_file_id_by_object_name(self, bucket: str, object_name: str) -> Optional[int]:
        """Object NameからFILE_IDを取得"""
        if not self._ensure_db_connection():
            return None
        
        try:
            with self.db_connection.cursor() as cursor:
                cursor.execute("""
                    SELECT FILE_ID 
                    FROM FILE_INFO 
                    WHERE BUCKET = :bucket AND OBJECT_NAME = :object_name
                """, {
                    'bucket': bucket,
                    'object_name': object_name
                })
                
                result = cursor.fetchone()
                return result[0] if result else None
                
        except Exception as e:
            logger.error(f"FILE_ID取得エラー: {e}")
            return None
        finally:
            # 接続をクローズ
            self._release_db_connection()

    def _release_db_connection(self):
        """接続をクローズ"""
        if self.db_connection:
            from app.services.database_service import database_service
            try:
                database_service._release_connection(self.db_connection)
                self.db_connection = None
                logger.debug("データベース接続をクローズしました")
            except Exception as e:
                logger.error(f"接続クローズエラー: {e}")
    
    def get_vectorization_status(self, bucket: str, object_names: List[str]) -> Dict[str, bool]:
        """
        複数ファイルのベクトル化状態を一括取得
        
        Args:
            bucket: バケット名
            object_names: オブジェクト名のリスト
            
        Returns:
            Dict[object_name, has_embeddings] - 各ファイルのベクトル化状態
        """
        result = {name: False for name in object_names}
        
        if not object_names:
            return result
        
        if not self._ensure_db_connection():
            logger.warning("DB接続なし、ベクトル化状態をすべてFalseで返します")
            return result
        
        try:
            with self.db_connection.cursor() as cursor:
                # FILE_INFOテーブルとIMG_EMBEDDINGSテーブルを結合して、
                # 各ファイルにembeddingが存在するかチェック
                placeholders = ', '.join([f":obj_{i}" for i in range(len(object_names))])
                
                query = f"""
                    SELECT f.OBJECT_NAME, 
                           CASE WHEN e.FILE_ID IS NOT NULL THEN 1 ELSE 0 END as HAS_EMBEDDINGS
                    FROM FILE_INFO f
                    LEFT JOIN (
                        SELECT DISTINCT FILE_ID FROM IMG_EMBEDDINGS
                    ) e ON f.FILE_ID = e.FILE_ID
                    WHERE f.BUCKET = :bucket 
                    AND f.OBJECT_NAME IN ({placeholders})
                """
                
                # パラメータを構築
                params = {'bucket': bucket}
                for i, name in enumerate(object_names):
                    params[f'obj_{i}'] = name
                
                cursor.execute(query, params)
                rows = cursor.fetchall()
                
                for row in rows:
                    object_name = row[0]
                    has_embeddings = row[1] == 1
                    result[object_name] = has_embeddings
                
                logger.info(f"ベクトル化状態取得完了: {len(rows)}件のファイルを確認")
                return result
                
        except Exception as e:
            logger.error(f"ベクトル化状態取得エラー: {e}")
            return result
        finally:
            self._release_db_connection()
    
    def search_similar_images(self, query_embedding: np.ndarray, limit: int = 10, threshold: float = 0.7) -> Optional[List[Dict[str, Any]]]:
        """
        類似画像を検索（2テーブルJOIN）
        
        Args:
            query_embedding: 検索用のembeddingベクトル
            limit: 最大取得件数
            threshold: 類似度闾値（0.0-1.0）
            
        Returns:
            類似画像のリスト（FILE_INFOとIMG_EMBEDDINGSをJOINした結果）
        """
        if not self._ensure_db_connection():
            logger.error("データベース接続がありません")
            return None
        
        try:
            # NumPy配列をFLOAT32配列に変換
            embedding_array = array.array("f", query_embedding.tolist())
            
            with self.db_connection.cursor() as cursor:
                # FILE_INFOとIMG_EMBEDDINGSをJOINしてベクトル検索
                sql = """
                SELECT 
                    ie.ID as embed_id,
                    ie.FILE_ID as file_id,
                    ie.BUCKET as bucket,
                    ie.OBJECT_NAME as object_name,
                    ie.PAGE_NUMBER as page_number,
                    ie.CONTENT_TYPE as content_type,
                    ie.FILE_SIZE as img_file_size,
                    f.BUCKET as file_bucket,
                    f.OBJECT_NAME as file_object_name,
                    f.ORIGINAL_FILENAME as original_filename,
                    f.FILE_SIZE as file_size,
                    f.CONTENT_TYPE as file_content_type,
                    f.UPLOADED_AT as uploaded_at,
                    VECTOR_DISTANCE(ie.EMBEDDING, :query_embedding, COSINE) as vector_distance
                FROM 
                    IMG_EMBEDDINGS ie
                INNER JOIN 
                    FILE_INFO f ON ie.FILE_ID = f.FILE_ID
                WHERE 
                    VECTOR_DISTANCE(ie.EMBEDDING, :query_embedding, COSINE) <= :threshold
                ORDER BY 
                    vector_distance
                FETCH FIRST :limit ROWS ONLY
                """
                
                cursor.execute(sql, {
                    'query_embedding': embedding_array,
                    'threshold': threshold,
                    'limit': limit
                })
                
                results = []
                for row in cursor:
                    # タイムスタンプをISO形式に変換
                    uploaded_at = row[12]
                    uploaded_at_str = uploaded_at.isoformat() if uploaded_at else None
                    
                    results.append({
                        'embed_id': row[0],
                        'file_id': row[1],
                        'bucket': row[2],
                        'object_name': row[3],
                        'page_number': row[4],
                        'content_type': row[5],
                        'img_file_size': row[6],
                        'file_bucket': row[7],
                        'file_object_name': row[8],
                        'original_filename': row[9],
                        'file_size': row[10],
                        'file_content_type': row[11],
                        'uploaded_at': uploaded_at_str,
                        'vector_distance': float(row[13])
                    })
                
                logger.info(f"ベクトル検索完了: {len(results)}件の画像がマッチ, threshold={threshold}")
                return results
                
        except Exception as e:
            logger.error(f"ベクトル検索エラー: {e}", exc_info=True)
            return None
        finally:
            self._release_db_connection()
    
    async def search_similar_images_async(self, query_embedding: np.ndarray, limit: int = 10, threshold: float = 0.7) -> Optional[List[Dict[str, Any]]]:
        """
        非同期バージョン: 類似画像を検索（イベントループをブロックしない）
        
        Thin modeでは oracledb.connect_async() を使用して真の非同期接続を実現
        
        Args:
            query_embedding: 検索用のembeddingベクトル
            limit: 最大取得件数
            threshold: 類似度闾値（0.0-1.0）
            
        Returns:
            類似画像のリスト、または失敗時はNone
        """
        import asyncio
        from app.services.database_service import database_service
        
        connection = None
        try:
            # タイムアウト付きで非同期接続を作成
            logger.info("非同期ベクトル検索: DB接続開始")
            try:
                connection = await asyncio.wait_for(
                    database_service._create_connection_async(),
                    timeout=10.0  # 10秒タイムアウト
                )
            except asyncio.TimeoutError:
                logger.error("非同期ベクトル検索: 接続タイムアウト")
                return None
            
            if not connection:
                logger.error("非同期ベクトル検索: DB接続失敗")
                return None
            
            logger.info("非同期ベクトル検索: DB接続成功")
            
            # NumPy配列をFLOAT32配列に変換
            embedding_array = array.array("f", query_embedding.tolist())
            
            # Thin mode: 非同期カーソルを直接使用
            cursor = None
            try:
                cursor = connection.cursor()
                sql = """
                SELECT 
                    ie.ID as embed_id,
                    ie.FILE_ID as file_id,
                    ie.BUCKET as bucket,
                    ie.OBJECT_NAME as object_name,
                    ie.PAGE_NUMBER as page_number,
                    ie.CONTENT_TYPE as content_type,
                    ie.FILE_SIZE as img_file_size,
                    f.BUCKET as file_bucket,
                    f.OBJECT_NAME as file_object_name,
                    f.ORIGINAL_FILENAME as original_filename,
                    f.FILE_SIZE as file_size,
                    f.CONTENT_TYPE as file_content_type,
                    f.UPLOADED_AT as uploaded_at,
                    VECTOR_DISTANCE(ie.EMBEDDING, :query_embedding, COSINE) as vector_distance
                FROM 
                    IMG_EMBEDDINGS ie
                INNER JOIN 
                    FILE_INFO f ON ie.FILE_ID = f.FILE_ID
                WHERE 
                    VECTOR_DISTANCE(ie.EMBEDDING, :query_embedding, COSINE) <= :threshold
                ORDER BY 
                    vector_distance
                FETCH FIRST :limit ROWS ONLY
                """
                
                await cursor.execute(sql, {
                    'query_embedding': embedding_array,
                    'threshold': threshold,
                    'limit': limit
                })
                
                results = []
                async for row in cursor:
                    uploaded_at = row[12]
                    uploaded_at_str = uploaded_at.isoformat() if uploaded_at else None
                    
                    results.append({
                        'embed_id': row[0],
                        'file_id': row[1],
                        'bucket': row[2],
                        'object_name': row[3],
                        'page_number': row[4],
                        'content_type': row[5],
                        'img_file_size': row[6],
                        'file_bucket': row[7],
                        'file_object_name': row[8],
                        'original_filename': row[9],
                        'file_size': row[10],
                        'file_content_type': row[11],
                        'uploaded_at': uploaded_at_str,
                        'vector_distance': float(row[13])
                    })
                
                logger.info(f"非同期ベクトル検索完了: {len(results)}件の画像がマッチ, threshold={threshold}")
                return results
            finally:
                if cursor:
                    cursor.close()
                
        except Exception as e:
            logger.error(f"非同期ベクトル検索エラー: {e}", exc_info=True)
            return None
        finally:
            if connection:
                try:
                    # Thin mode: 非同期close()を使用
                    await connection.close()
                    logger.info("非同期DB接続をクローズしました")
                except Exception as e:
                    logger.error(f"非同期接続クローズエラー: {e}")


# グローバルインスタンス
image_vectorizer = ImageVectorizer()
