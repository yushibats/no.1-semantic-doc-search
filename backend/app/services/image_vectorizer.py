"""
画像ベクトル化サービス
OCI Generative AI Embedding Modelを使用して画像をベクトル化し、DBに保存
"""
import logging
import os
import io
import array
import time
from typing import Optional, List, Dict, Any
from pathlib import Path
import numpy as np
from PIL import Image
import base64
import oracledb
import oci
from pdf2image import convert_from_path

logger = logging.getLogger(__name__)


class ImageVectorizer:
    """画像ベクトル化クラス"""
    
    def __init__(self):
        self.genai_client = None
        self.db_connection = None
        self._initialize_genai_only()
        logger.info("ImageVectorizerを初期化しました（DB接続プールは未作成）")
    
    def _initialize_genai_only(self):
        """OCIクライアントのみを初期化（DB接続は遅延作成）"""
        try:
            # OCI設定を読み込み
            config_file = os.path.expanduser("~/.oci/config")
            profile = os.getenv("OCI_PROFILE", "DEFAULT")
            
            if not os.path.exists(config_file):
                logger.warning(f"OCI設定ファイルが見つかりません: {config_file}")
                return
            
            config = oci.config.from_file(file_location=config_file, profile_name=profile)
            
            # OCI Generative AI Clientを初期化
            region = os.getenv("OCI_REGION", "us-chicago-1")
            service_endpoint = f"https://inference.generativeai.{region}.oci.oraclecloud.com"
            
            self.genai_client = oci.generative_ai_inference.GenerativeAiInferenceClient(
                config=config,
                service_endpoint=service_endpoint,
                retry_strategy=oci.retry.NoneRetryStrategy(),
                timeout=(10, 240)
            )
            
            logger.info("OCI Generative AIクライアント初期化成功")
            
        except Exception as e:
            logger.error(f"GenAI初期化エラー: {e}")
            self.genai_client = None
    
    def _ensure_db_connection(self, max_retries: int = 3) -> bool:
        """データベース接続を確保（database_serviceのプールを利用）"""
        from app.services.database_service import database_service
        
        # 既存接続が有効かチェック
        if self.db_connection:
            if self.is_connected():
                return True
            else:
                logger.warning("既存のDB接続が無効です")
                # 無効な接続をプールに返却
                try:
                    database_service._release_connection(self.db_connection)
                except:
                    pass
                self.db_connection = None
        
        # database_serviceから接続を取得（リトライ付き）
        for attempt in range(1, max_retries + 1):
            try:
                logger.info(f"DB接続取得試行 {attempt}/{max_retries}")
                self.db_connection = database_service._create_connection()
                if self.db_connection:
                    logger.info(f"DB接続取得成功 (試行{attempt}回目)")
                    # テーブル存在確認
                    self._ensure_tables_exist()
                    return True
            except Exception as e:
                logger.error(f"DB接続取得失敗 (試行{attempt}/{max_retries}): {e}")
                if attempt == max_retries:
                    logger.error("DB接続取得の最大リトライ回数に達しました")
                    return False
                # リトライ前に少し待機
                import time
                time.sleep(1)
        
        return False
    

    
    def is_connected(self) -> bool:
        """データベース接続状態をチェック"""
        try:
            if self.db_connection is None:
                return False
            # 簡単なクエリでテスト
            with self.db_connection.cursor() as cursor:
                cursor.execute("SELECT 1 FROM DUAL")
                cursor.fetchone()
            return True
        except Exception:
            return False
    
    def _ensure_tables_exist(self):
        """必要なテーブルが存在することを確認し、なければ作成"""
        if not self.db_connection:
            return
        
        try:
            with self.db_connection.cursor() as cursor:
                # FILE_INFOテーブルの存在確認
                cursor.execute("""
                    SELECT COUNT(*) 
                    FROM USER_TABLES 
                    WHERE TABLE_NAME = 'FILE_INFO'
                """)
                file_info_exists = cursor.fetchone()[0] > 0
                
                if not file_info_exists:
                    logger.info("FILE_INFOテーブルを作成します...")
                    cursor.execute("""
                        CREATE TABLE FILE_INFO (
                            FILE_ID NUMBER GENERATED BY DEFAULT AS IDENTITY 
                                MINVALUE 1 
                                MAXVALUE 9999999999999999999999999999 
                                INCREMENT BY 1 
                                START WITH 1 
                                CACHE 20 
                                NOORDER NOCYCLE NOKEEP NOSCALE,
                            BUCKET VARCHAR2(128 BYTE) COLLATE USING_NLS_COMP,
                            OBJECT_NAME VARCHAR2(1024 BYTE) COLLATE USING_NLS_COMP,
                            ORIGINAL_FILENAME VARCHAR2(1024 BYTE) COLLATE USING_NLS_COMP,
                            FILE_SIZE NUMBER,
                            CONTENT_TYPE VARCHAR2(128 BYTE) COLLATE USING_NLS_COMP,
                            UPLOADED_AT TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
                            CONSTRAINT PK_FILE_INFO PRIMARY KEY (FILE_ID)
                        ) DEFAULT COLLATION USING_NLS_COMP
                    """)
                    self.db_connection.commit()
                    logger.info("FILE_INFOテーブル作成完了")
                
                # IMG_EMBEDDINGSテーブルの存在確認
                cursor.execute("""
                    SELECT COUNT(*) 
                    FROM USER_TABLES 
                    WHERE TABLE_NAME = 'IMG_EMBEDDINGS'
                """)
                img_embeddings_exists = cursor.fetchone()[0] > 0
                
                if not img_embeddings_exists:
                    logger.info("IMG_EMBEDDINGSテーブルを作成します...")
                    cursor.execute("""
                        CREATE TABLE IMG_EMBEDDINGS (
                            ID NUMBER GENERATED BY DEFAULT AS IDENTITY 
                                MINVALUE 1 
                                MAXVALUE 9999999999999999999999999999 
                                INCREMENT BY 1 
                                START WITH 1 
                                CACHE 20 
                                NOORDER NOCYCLE NOKEEP NOSCALE,
                            FILE_ID NUMBER,
                            BUCKET VARCHAR2(128 BYTE) COLLATE USING_NLS_COMP,
                            OBJECT_NAME VARCHAR2(1024 BYTE) COLLATE USING_NLS_COMP,
                            PAGE_NUMBER NUMBER,
                            CONTENT_TYPE VARCHAR2(128 BYTE) COLLATE USING_NLS_COMP,
                            FILE_SIZE NUMBER,
                            UPLOADED_AT TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
                            EMBEDDING VECTOR(1536, FLOAT32),
                            CONSTRAINT PK_IMG_EMBEDDINGS PRIMARY KEY (ID),
                            CONSTRAINT FK_IMG_FILE FOREIGN KEY (FILE_ID) 
                                REFERENCES FILE_INFO(FILE_ID) ON DELETE CASCADE
                        ) DEFAULT COLLATION USING_NLS_COMP
                    """)
                    self.db_connection.commit()
                    logger.info("IMG_EMBEDDINGSテーブル作成完了")
                
        except Exception as e:
            logger.error(f"テーブル作成エラー: {e}")
            if self.db_connection:
                self.db_connection.rollback()
    
    def _image_to_base64(self, image_data: io.BytesIO, content_type: str = "image/png") -> str:
        """画像データをbase64エンコード"""
        image_data.seek(0)
        image_bytes = image_data.read()
        base64_string = base64.b64encode(image_bytes).decode('utf-8')
        return f"data:{content_type};base64,{base64_string}"
    
    def generate_embedding(self, image_data: io.BytesIO, content_type: str = "image/png") -> Optional[np.ndarray]:
        """画像からembeddingベクトルを生成"""
        if not self.genai_client:
            logger.error("OCI Generative AIクライアントが初期化されていません")
            return None
        
        try:
            # 画像をbase64エンコード
            base64_image = self._image_to_base64(image_data, content_type)
            
            # Embedding生成リクエストを作成
            embed_detail = oci.generative_ai_inference.models.EmbedTextDetails()
            embed_detail.serving_mode = oci.generative_ai_inference.models.OnDemandServingMode(
                model_id=os.getenv("OCI_COHERE_EMBED_MODEL", "cohere.embed-v4.0")
            )
            embed_detail.input_type = os.getenv("OCI_EMBEDDING_INPUT_TYPE", "IMAGE")
            embed_detail.inputs = [base64_image]
            embed_detail.truncate = os.getenv("OCI_EMBEDDING_TRUNCATE", "END")
            embed_detail.compartment_id = os.getenv("OCI_COMPARTMENT_OCID")
            
            # リトライロジック
            max_retries = int(os.getenv("OCI_EMBEDDING_MAX_RETRIES", "3"))
            retry_delay = int(os.getenv("OCI_EMBEDDING_RETRY_DELAY", "1"))
            
            for retry in range(max_retries):
                try:
                    response = self.genai_client.embed_text(embed_detail)
                    
                    if response.data.embeddings:
                        embedding = response.data.embeddings[0]
                        embedding_array = np.array(embedding, dtype=np.float32)
                        
                        logger.info(f"画像embedding生成成功: shape={embedding_array.shape}")
                        return embedding_array
                    else:
                        logger.error("Embeddingが空です")
                        return None
                
                except Exception as e:
                    if retry < max_retries - 1:
                        logger.warning(f"Embedding生成失敗 (リトライ {retry + 1}/{max_retries}): {e}")
                        time.sleep(retry_delay)
                    else:
                        logger.error(f"Embedding生成失敗（最大リトライ回数到達）: {e}")
                        return None
            
            return None
            
        except Exception as e:
            logger.error(f"予期しないエラー: {e}")
            return None
    
    def save_file_info(self, bucket: str, object_name: str, original_filename: str, 
                      file_size: int, content_type: str) -> Optional[int]:
        """ファイル情報をFILE_INFOテーブルに保存"""
        if not self._ensure_db_connection():
            logger.error("データベース接続がありません")
            return None
        
        try:
            with self.db_connection.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO FILE_INFO 
                    (BUCKET, OBJECT_NAME, ORIGINAL_FILENAME, FILE_SIZE, CONTENT_TYPE)
                    VALUES (:bucket, :object_name, :original_filename, :file_size, :content_type)
                    RETURNING FILE_ID INTO :file_id
                """, {
                    'bucket': bucket,
                    'object_name': object_name,
                    'original_filename': original_filename,
                    'file_size': file_size,
                    'content_type': content_type,
                    'file_id': cursor.var(oracledb.NUMBER)
                })
                
                file_id_var = cursor.bindvars['file_id']
                file_id = file_id_var.getvalue()
                
                if isinstance(file_id, list) and len(file_id) > 0:
                    file_id = file_id[0]
                
                self.db_connection.commit()
                
                logger.info(f"ファイル情報保存成功: FILE_ID={file_id}")
                return int(file_id)
                
        except Exception as e:
            logger.error(f"ファイル情報保存エラー: {e}")
            if self.db_connection:
                self.db_connection.rollback()
            return None
        finally:
            # 接続をプールに返却
            self._release_db_connection()
    
    def save_image_embedding(self, file_id: int, bucket: str, object_name: str, 
                           page_number: int, content_type: str, file_size: int, 
                           embedding: np.ndarray) -> Optional[int]:
        """画像embeddingをIMG_EMBEDDINGSテーブルに保存"""
        if not self._ensure_db_connection():
            logger.error("データベース接続がありません")
            return None
        
        try:
            # NumPy配列をFLOAT32配列に変換
            embedding_array = array.array("f", embedding.tolist())
            
            with self.db_connection.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO IMG_EMBEDDINGS 
                    (FILE_ID, BUCKET, OBJECT_NAME, PAGE_NUMBER, CONTENT_TYPE, FILE_SIZE, EMBEDDING)
                    VALUES (:file_id, :bucket, :object_name, :page_number, :content_type, :file_size, :embedding)
                    RETURNING ID INTO :id
                """, {
                    'file_id': file_id,
                    'bucket': bucket,
                    'object_name': object_name,
                    'page_number': page_number,
                    'content_type': content_type,
                    'file_size': file_size,
                    'embedding': embedding_array,
                    'id': cursor.var(oracledb.NUMBER)
                })
                
                id_var = cursor.bindvars['id']
                embedding_id = id_var.getvalue()
                
                if isinstance(embedding_id, list) and len(embedding_id) > 0:
                    embedding_id = embedding_id[0]
                
                self.db_connection.commit()
                
                logger.info(f"画像embedding保存成功: ID={embedding_id}, FILE_ID={file_id}, PAGE={page_number}")
                return int(embedding_id)
                
        except Exception as e:
            logger.error(f"画像embedding保存エラー: {e}")
            if self.db_connection:
                self.db_connection.rollback()
            return None
        finally:
            # 接続をプールに返却
            self._release_db_connection()
    
    def delete_file_embeddings(self, file_id: int) -> bool:
        """ファイルに関連するすべてのembeddingを削除"""
        if not self._ensure_db_connection():
            logger.error("データベース接続がありません")
            return False
        
        try:
            with self.db_connection.cursor() as cursor:
                cursor.execute("""
                    DELETE FROM IMG_EMBEDDINGS 
                    WHERE FILE_ID = :file_id
                """, {'file_id': file_id})
                
                deleted_count = cursor.rowcount
                self.db_connection.commit()
                
                logger.info(f"FILE_ID={file_id}のembedding削除完了: {deleted_count}件")
                return True
                
        except Exception as e:
            logger.error(f"Embedding削除エラー: {e}")
            if self.db_connection:
                self.db_connection.rollback()
            return False
        finally:
            # 接続をプールに返却
            self._release_db_connection()
    
    def get_file_id_by_object_name(self, bucket: str, object_name: str) -> Optional[int]:
        """Object NameからFILE_IDを取得"""
        if not self._ensure_db_connection():
            return None
        
        try:
            with self.db_connection.cursor() as cursor:
                cursor.execute("""
                    SELECT FILE_ID 
                    FROM FILE_INFO 
                    WHERE BUCKET = :bucket AND OBJECT_NAME = :object_name
                """, {
                    'bucket': bucket,
                    'object_name': object_name
                })
                
                result = cursor.fetchone()
                return result[0] if result else None
                
        except Exception as e:
            logger.error(f"FILE_ID取得エラー: {e}")
            return None
        finally:
            # 接続をプールに返却
            self._release_db_connection()

    def _release_db_connection(self):
        """接続をプールに返却"""
        if self.db_connection:
            from app.services.database_service import database_service
            try:
                database_service._release_connection(self.db_connection)
                self.db_connection = None
            except Exception as e:
                logger.error(f"接続返却エラー: {e}")


# グローバルインスタンス
image_vectorizer = ImageVectorizer()
